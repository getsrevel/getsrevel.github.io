<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Arduino :: Getsrevel</title><link>https://getsrevel.github.io/tech/arduino/index.html</link><description>Eksempler med Arduino.</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 08 Sep 2020 14:10:00 +0200</lastBuildDate><atom:link href="https://getsrevel.github.io/tech/arduino/index.xml" rel="self" type="application/rss+xml"/><item><title>Button Trigger</title><link>https://getsrevel.github.io/tech/arduino/button-trigger/index.html</link><pubDate>Tue, 08 Sep 2020 14:10:00 +0200</pubDate><guid>https://getsrevel.github.io/tech/arduino/button-trigger/index.html</guid><description>Dette eksempel viser hvordan man kan måle tiden mellem to hændelser.
Pin 2: starter timer når forbindelsen til GND afbrydes. Pin 3: stopper tidtagningen når forbindelsen til GND sluttes. Den indbyggede LED er tændt, mens tidtagningen er i gang.
const int startPin = 2; const int gatePin = 3; const int ledPin = 13; int isStarted = false; int hasTriggeredGate = false; unsigned long startTime = 0; unsigned long gateTime = 0; void setup() { pinMode(ledPin, OUTPUT); pinMode(startPin, INPUT_PULLUP); pinMode(gatePin, INPUT_PULLUP); Serial.begin(9600); Serial.println("Ready..."); } void loop() { int startState = digitalRead(startPin); // Turn on LED while measurement is running int measRunning = isStarted &amp;&amp; !hasTriggeredGate; digitalWrite(ledPin, measRunning); // Handle start trigger if (HIGH == startState &amp;&amp; !isStarted) { startTime = millis(); isStarted = true; Serial.print("Start time 1: "); Serial.println(startTime); } // Handle gate trigger int gateState = digitalRead(gatePin); if (LOW == gateState &amp;&amp; !hasTriggeredGate) { gateTime = millis(); hasTriggeredGate = true; Serial.print("Gate time: "); Serial.println(gateTime); Serial.print("Time diff: "); unsigned long timeDiff = gateTime - startTime; Serial.println(timeDiff); } }</description></item><item><title>Neopixel</title><link>https://getsrevel.github.io/tech/arduino/neopixel/index.html</link><pubDate>Sat, 05 Sep 2020 12:21:05 +0200</pubDate><guid>https://getsrevel.github.io/tech/arduino/neopixel/index.html</guid><description>Dette eksempel laver et “løbelys” med blå farver.
Hardware setup Arduino og LED array hardware LED modulerne er forbunde i en kæde, så data signalets output er forbundet til input på næste LED modul. Alle modulerne forsynes med 5V fra arduino. Der er monteret en kondensator for at udjævne spændingen. Datasignalet tages fra pin 6 på Arduino.
Arduino &amp; NeoPixel For at kunne styre arrayet af NeoPixel LED’er kan du benytte softwarebiblioteket Adafruit Neopixel.</description></item><item><title>Hex String</title><link>https://getsrevel.github.io/tech/arduino/hex-string/index.html</link><pubDate>Wed, 22 Apr 2020 13:21:41 +0200</pubDate><guid>https://getsrevel.github.io/tech/arduino/hex-string/index.html</guid><description>Dette eksempel illustrerer hvordan man kan arbejde med strenge, og konvertere de enkelte bytes i en streng til hex tal med foranstillede nuller.
char my_str[] = {72, 101, 106, 44, 32, 10, 86, 101, 114, 100, 101, 110, 33, 0}; char outputBuffer[3]; // Helper function for converting byte value to 2-digit hex string void byte2HexStr(byte val, char* outputBuffer){ const char HEX_DIGITS[16] = "0123456789ABCDEF"; byte upper_nibble_index = (val &amp; 0xf0) >> 4; byte lower_nibble_index = val &amp; 0xf; outputBuffer[0] = HEX_DIGITS[upper_nibble_index]; outputBuffer[1] = HEX_DIGITS[lower_nibble_index]; outputBuffer[2] = '\0'; } void setup() { Serial.begin(115200); // Output some example strings Serial.println("Content:"); Serial.println(my_str); Serial.println(); Serial.println("Content, decimal values of bytes:"); for(int i = 0; i &lt; sizeof(my_str); i++) { Serial.print(my_str[i], DEC); Serial.print(" "); } Serial.println('\n'); Serial.println("Content, hex values of bytes:"); for(int i = 0; i &lt; sizeof(my_str); i++) { Serial.print(my_str[i], HEX); Serial.print(" "); } Serial.println('\n'); Serial.println("Content, hex values zero-padded bytes:"); for(int i = 0; i &lt; sizeof(my_str); i++) { byte2HexStr(my_str[i], outputBuffer); Serial.print(outputBuffer); Serial.print(" "); } Serial.println('\n'); Serial.println("Content, append to string object:"); String myStrObject = ""; for(int i = 0; i &lt; sizeof(my_str); i++) { myStrObject += String(my_str[i], HEX); } Serial.println(myStrObject); Serial.println(); Serial.println("Content, append to string object using byte2HexStr helper:"); myStrObject = ""; for(int i = 0; i &lt; sizeof(my_str); i++) { byte2HexStr(my_str[i], outputBuffer); myStrObject += outputBuffer; } Serial.println(myStrObject); Serial.println(); Serial.println("Content, append to string object with separator:"); myStrObject = ""; for(int i = 0; i &lt; sizeof(my_str); i++) { myStrObject += String(my_str[i], HEX); // add separator except for the last element if(i &lt; (sizeof(my_str) - 1)){ myStrObject += ":"; } } Serial.println(myStrObject); Serial.println(); Serial.println("Content, append to string object using byte2HexStr helper with separator:"); myStrObject = ""; for(int i = 0; i &lt; sizeof(my_str); i++) { byte2HexStr(my_str[i], outputBuffer); myStrObject += outputBuffer; // add separator except for the last element if(i &lt; (sizeof(my_str) - 1)){ myStrObject += ":"; } } Serial.println(myStrObject); Serial.println(); } void loop() { }Når eksemplet køres på en arduino generes dette output på seriel porten.</description></item><item><title>Json Command Receiver</title><link>https://getsrevel.github.io/tech/arduino/json-command-receiver/index.html</link><pubDate>Wed, 22 Apr 2020 13:21:41 +0200</pubDate><guid>https://getsrevel.github.io/tech/arduino/json-command-receiver/index.html</guid><description>Dette eksempel viser hvordan man kan bruge JSON data formatet til at udveksle information med en arduino og sende kommandoer via seriel porten.
Ved at sende en passende kommando kan man ændre på hastighed og duty cycle for en blinkende LED.
For nemt at kunne arbejde med JSON i Arduino koden benyttes biblioteket Arduino JSON. Derfor er det nødvendigt at installere dette på udviklingsmaskinen, inden denne sketch kan kompileres, det klares via. Arduino Library Manager, se hvordan du installerer det her.</description></item><item><title>Task Loop using Function Pointers</title><link>https://getsrevel.github.io/tech/arduino/task-loop-functions/index.html</link><pubDate>Wed, 22 Apr 2020 13:21:41 +0200</pubDate><guid>https://getsrevel.github.io/tech/arduino/task-loop-functions/index.html</guid><description>Dette eksempel illustrerer, hvordan man kan bruge function pointers til at køre forskellige opgaver med hvert sit interval, uden at de blokerer for hinanden i længere tid end det tager at eksekvere en enkelt opgave.
typedef struct MyTask { void (*handler)(); int intervalMs; int taskId; unsigned long lastRunMs; } MyTask; // Forward declaration of the task runner functions void task_main(); void task_A(); void task_B(); void task_C(); MyTask tasks[] = { {.handler=task_main}, {task_A,300}, {task_B,500}, {task_C,3000} }; const int arrSize = sizeof(tasks)/sizeof(MyTask); void setup() { // initialize serial communication at 115200 bits per second: Serial.begin(115200); Serial.print("Task count: "); Serial.println(arrSize); for(int i=0 ; i&lt;arrSize; i++){ if(tasks[i].intervalMs &lt;= 0){ tasks[i].intervalMs = (i+1)*100; } String msg = ""; msg = "task id: "; msg += i; msg += ", interval "; msg += tasks[i].intervalMs; Serial.println(msg); } Serial.println("Setup DONE"); } // example of non-blocking asyncronous wait loop using function pointers void loop() { for(int i=0 ; i&lt;arrSize; i++){ runInterval(&amp;tasks[i]); } } void runInterval(struct MyTask *t){ unsigned long tickMs = millis(); unsigned long diffMs = tickMs - t->lastRunMs; // Handle first run if(0 == t->lastRunMs){ t->lastRunMs = tickMs; } bool shouldRun = (t->intervalMs &lt; diffMs); if(!shouldRun){ return; } // Store last run t->lastRunMs = tickMs; // Perform the process by calling the handler function (t->handler)(); } // Create some tasks to run in the example void task_main(){ static int runCount = 0; Serial.print("."); if(0 == runCount % 30){ Serial.println(); Serial.print(runCount); Serial.print(" : "); } runCount++; } void task_A(){ Serial.print("A"); } void task_B(){ Serial.print("B"); } void task_C(){ Serial.print("C"); }Når eksemplet køres på en arduino generes dette output på seriel porten.</description></item><item><title>Json Beacon</title><link>https://getsrevel.github.io/tech/arduino/json-beacon/index.html</link><pubDate>Tue, 31 Mar 2020 16:59:21 +0200</pubDate><guid>https://getsrevel.github.io/tech/arduino/json-beacon/index.html</guid><description>Dette eksempel illustrerer hvordan man kan generere json output på seriel porten, og er tænkt som en en stub der kan bruges til at arbejde med seriel input på en en anden computer, f.eks. vha. node.js.
#include &lt;ArduinoJson.h> const int WAIT_MS_MIN = 500; const int WAIT_MS_MAX = 8000; const unsigned char TAG_COUNT = 5; char* tagIds[TAG_COUNT] = { "4B 61 73 70 65 72 36 37 38 39 3A 3B", "E2 00 00 1B 63 15 02 48 16 00 DB 24", "E2 00 00 1B 63 15 02 48 17 00 DA F8", "E2 00 00 1B 63 15 02 48 17 20 DA F4", "E2 00 00 1B 63 15 02 48 15 90 DB 2C", }; int pinOne = 2; int pinTwo = 3; void setup() { Serial.begin(115200); pinMode(pinOne, INPUT_PULLUP); pinMode(pinTwo, INPUT_PULLUP); } void loop() { int waitTime = random(WAIT_MS_MIN, WAIT_MS_MAX); int tagIdIndex = random(0, TAG_COUNT); bool isRandom = true; if(!digitalRead(pinOne)){ tagIdIndex = 0; isRandom = false; waitTime = 300; } if(!digitalRead(pinTwo)){ tagIdIndex = 1; isRandom = false; waitTime = 150; } DynamicJsonDocument doc(1024); // Insert some debugging information doc["isRandom"] = isRandom; doc["waitTime"] = waitTime; doc["tagIdIndex"] = tagIdIndex; // Insert the selected tag ID doc["tagId"] = tagIds[tagIdIndex]; serializeJson(doc, Serial); Serial.println(); delay(waitTime); }Der vælges en tilfældig værdi i tagIds arrayet, som så serialiseres som json sammen med oplysning om index og delay tiden, og udskrives på serielporten med tilfældige tidsintervaller.</description></item></channel></rss>